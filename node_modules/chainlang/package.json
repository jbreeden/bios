{
  "name": "chainlang",
  "version": "0.1.2",
  "description": "Utility for easily creating chainable methods and complex fluent APIs in JavaScript",
  "main": "chainlang.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/jbreeden/chainlang"
  },
  "keywords": [
    "Node.js",
    "fluent",
    "chain"
  ],
  "author": {
    "name": "Jared Breeden"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "readme": "Chainlang\n=========\n\nChainlang is a utility for easily creating chainable methods and complex fluent APIs in JavaScript.\n\nMotivation\n==========\n\nFuent APIs make code easier to read and understand. Replacing a large options object parameter with a convenient\nfluent API can greatly simplify the use of many library functions. In an interactive environment like the\nnodejs repl, or the Firebug console, programmers can take advantage of auto-completion and exploratory programming\nto uncover the features of your fluent API without having to resort to the documentation.\n\nUsage\n=====\n\nCreating a Chainable API\n------------------------\n\nJust pass any JavaScript object to `chainlang.create` to create a chainable api:\n\n```\nvar adder = {\n    add: function(val){ \n        this._subject += val; \n    },\n    calc: function() { \n        return this._subject; \n    }\n}\n\nvar to = chainlang.create(adder);\n\n// Logs: 10\nconsole.log(\n    to(1).add(2).add(3).add(4).calc()\n);\n```\n\n`chainlang.create` will return a function that starts your chain expression. The optional parameter\nto this function will be saved in `this._subject` and accessible by all of your methods. If no value\nis returned by a method in the chain, the chain object itself is implicitly returned so you may\ncontinue to chain other methods.\n\nEverything is Chainable\n-----------------------\n\nThe object you pass to `chainlang.create` need not have all of it's method at the root level, as in\nthe example above. Any method on the object graph, no matter how deeply nested, will be chainable.\n\n```\nvar even = {\n    deeply: {\n        nested: {\n            methods: function(){\n                return;   \n            }\n        }\n    },\n    are: {\n        chainable: function(){\n            console.log(true);   \n        }\n    }\n};\n\nvar even = chainlang.create(even);\n\n// Logs: true\neven().deeply.nested.methods().are.chainable();\n```\n\nSkip The Initial Call\n---------------------\n\nAs mentioned, `chainlang.create` returns a function that will start your chain. This function returns the\nchain object that all of your subsequent method calls are applied to. While this is required to allow chaining,\nthe function call is only useful to clients if you want to capture some `_subject`. If you have no such need\nthe function call is extraneous. `chainlang` will allow you to skip this initial call, and still makes.\n\n```\n// TODO: Need example\n```\n\nUsing `chainlang.append`\n------------------------\n\n`chainlang.append` is a simple function to help you build your language spec before passing it to\n`chainlang.create`. With `chainlang.append`, you can declare leaf nodes of an object graph and\nhave the parent nodes filled in for you. So, the previous example could have been written like this:\n\n```\nvar even = {};\nchainlang.append(even, 'deeply.nested.methods', function(){ return; });\nchainlang.append(even, 'are.chainable', function(){ console.log(true); });\neven = chainlang.create(even);\n\n// Logs: true\neven().deeply.nested.methods().are.chainable();\n```\n\nIf you bind `chainlang.append` to some object, the first parameter may be omitted\n\n```\nvar even = {};\nvar define = chainlang.append.bind(even);\n\ndefine('deeply.nested.methods', function(){ return; });\ndefine('are.chainable', function(){ console.log(true); });\n\neven = chainlang.create(even);\n\n// Logs: true\neven().deeply.nested.methods().are.chainable();\n```\n\nSharing Data Between Links\n--------------------------\n\nAlong with `this._subject`, all method calls have access to `this._data`. `this._data` is initially\nempty, and is simply provided as a convenient place to store information between links in a chained\nexpression.\n\n```\nvar spec = {};\nvar define = chainlang.append.bind(spec);\n\ndefine('setData', function(val){ \n    this._data.field = val; \n});\ndefine('logData', function(){ \n    console.log(this._data.field); \n});\n\nvar chain = chainlang.create(spec);\n\n// Logs: 999\nchain().setData(999).logData();\n```\n\nKeeping Your Privates Hidden\n----------------------------\n\nSometimes it's desirable to hide some methods of your chainable api until it makes sense to use them.\n`chainlang` provides no built-in support for this, but it is recommended that you simply hide these nodes\nbehind a field with a name like '_private'. That way, programmers using your api will not be tempted to use\nthese methods in a context where it does not make sense to do so. Also, keeping them *all* behind\na field like this, instand of simply prefixing them all with an '_' will prevent the auto-completion\nresults from being cluttered with fields that are supposed to be private in the first place. For example:\n\n```\nvar delaySpec = {};\nvar define = chainlang.append.bind(delaySpec);\n\ndefine('for', function(count){\n    this._data.count = count;\n    \n    // exposing our private 'units' object now that we have a count\n    return this._private.units;\n});\n\ndefine('_private.units.seconds.then', function(callback){\n    setTimeout(callback, this._data.count * 1000);\n});\n\ndefine('_private.units.minutes.then', function(callback){\n    setTimeout(callback, this._data.count * 1000 * 60)\n});\n\nvar delay = chainlang.create(delaySpec);\n\n// After 5 seconds, logs: '5 seconds elapsed'\ndelay().for(5).seconds.then(function(){\n    console.log('5 seconds elapsed');\n});\n\n// After 5 minutes, logs: '5 minutes elapsed'\ndelay().for(5).minutes.then(function(){\n    console.log('5 minutes elapsed');\n});\n```\n\nIn the previous example, it would not make sense to have an expression such as `delay().minutes.then(...)`.\nThe count needs to be declared before the units, so the units object is kept in private storage and exposed\nby `return`ing it from the `for(count)` call.\n\nCreating Modifiers\n------------------\n\nWith fluent APIs, it can be useful to declare modifiers that alter the behavior of all methods that descend\nfrom them in the object graph. For this, chainlang exposes the `chainlang.proxy` method. This allows you to\ncreate a copy of an object with all of its methods proxied. This is the same technique used by\nchainlang to create an object with chainable methods in `chainlang.create`.\n\n```\nvar is = {};\n\n// `is.even(...)` determines whether a value is even\nis.even = function(){\n    return (this._subject % 2 === 0);\n};\n\n// `isNot` has all the same methods of `is`, but negates their returns\nvar isNot = chainlang.proxy(is, function(fn){\n    return function(){\n        return !fn.apply(this, arguments);  \n    };\n});\n\nis.not = isNot;\n\nis = chainlang.create(is);\n\n// Logs: true\nconsole.log(\n    is(68).even()\n);\n\n// Logs: false\nconsole.log(\n    is(68).not.even()\n);\n```\n\nMore Information\n================\n\n* [The chainlang spec](http://jbreeden.github.io/chainlang/spec/spec.html)\n* [Example: Creating a full-feature fromjs library](http://jbreeden.github.io/chainlang/fromjs/from.html)\n* [Annotated source of chainlang.js](http://jbreeden.github.io/chainlang/source/chainlang.html)\n",
  "bugs": {
    "url": "https://github.com/jbreeden/chainlang/issues"
  },
  "_id": "chainlang@0.1.2",
  "_from": "chainlang@"
}
